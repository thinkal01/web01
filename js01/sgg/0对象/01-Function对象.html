<!DOCTYPE html>
<html>
<head>
    <title>01-Function对象.html</title>

    <meta http-equiv="keywords" content="keyword1,keyword2,keyword3">
    <meta http-equiv="description" content="this is my page">
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">

    <script type="text/javascript">
        //1 对象的功能
        //Function对象=>特殊=>相当于java中的方法
        function fun1() {
            alert("hello");
        }

        alert(fun1); //打印函数定义

        //第二种方式创建函数
        var add3 = function (m, n) {
            alert(m + n);
        };

        //第三种方式创建函数,不能使用局部变量,可以使用全局变量
        // var function_name = new function (arg1, arg2,..., argN, function_body);
        var fun3 = new Function("alert('hello3');");
        var sayHi = new Function("sName", "sMessage", "alert(\"Hello \" + sName + sMessage);");

        var canshu = "x,y";
        var fangfati = "var sum;sum=x+y;return sum;";
        var add4 = new Function(canshu, fangfati);

        //3 对象的属性
        alert(fun2.length);//length属性代表函数参数个数

        //4 对象的方法,toString => 打印函数的定义
        //Function对象也有与所有对象共享的 valueOf()方法和 toString()方法。这两个方法返回的都是函数的源代码
        alert(fun1.toString());

        //与java一样,使用return关键字,也可以结束方法的调用
        function fun1(a, b) {
            alert(a + b);
            return a + b;
        }

        alert(fun1(1, 2));

        function fun2() {
            alert("haha");
            return;
            alert("heihei");
        }

        alert(fun2());//undefined
        //void运算符: 用于拦截方法的返回值.
        //形参列表arguments
        function fun1(a, b) {
            alert(a + b);
        }

        //调用
        fun1(1, 2);//3
        fun1(1, 2, 3, 4);//3
        fun1();//NaN
        //结论: js中的函数在调用时,只看函数名称.不看参数.

        // arguments  => 函数运行时,参数的封装
        // 任何的函数内部都隐式的维护了一个arguments（数组）对象，给函数传递数据的时候，
        // 会先传递到arguments对象中，然后再由arguments对象分配数据给形参
        function fun1() {
            alert(arguments.length);//打印实际传递参数个数
            var count = 0;
            for (var i = 0; i < arguments.length; i++) {
                count += arguments[i];
            }
        }

        //调用
        fun1(1, 2);//3
        fun1(1, 2, 3, 4);//10
        fun1();//0

        //函数没有重载的形式，后定义的函数会直接覆盖前面的函数。
        function add11(a, b) {
            return a + b;
        }

        function add11(a, b, c) {
            return a + b + c;
        }

        function add11(a, b, c, d) {
            return a + b + c + d;
        }

        alert(add11(2, 2));   //NaN
        alert(add11(2, 2, 3)); //NaN
        alert(add11(2, 2, 4, 5)); // 13
    </script>
</head>
<body>
<a href="javaScript:void(fun1(1,2));">点我</a>
<a href="javascript:fun1();">fun1</a>
<a href="javascript:fun2();">fun2</a>
<a href="javaScript:void(0)" onclick="alert('haha')">点我</a>
</body>
</html>